const User = require('../models/User');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

// Cr√©er un nouvel utilisateur
exports.register = async (req, res) => {
  try {
    console.log('üìù Tentative d\'inscription avec:', req.body);
    const { email, password, username } = req.body;
    
    // Validation des donn√©es
    if (!email || !password || !username) {
      console.log('‚ùå Donn√©es manquantes:', { email: !!email, password: !!password, username: !!username });
      return res.status(400).json({ message: 'Tous les champs sont requis' });
    }

    // V√©rification de l'email
    if (!/\S+@\S+\.\S+/.test(email)) {
      console.log('‚ùå Format d\'email invalide:', email);
      return res.status(400).json({ message: 'Format d\'email invalide' });
    }

    // V√©rification du nom d'utilisateur
    if (username.length < 3) {
      console.log('‚ùå Nom d\'utilisateur trop court:', username);
      return res.status(400).json({ message: 'Le nom d\'utilisateur doit contenir au moins 3 caract√®res' });
    }

    // V√©rification du mot de passe
    if (password.length < 6) {
      console.log('‚ùå Mot de passe trop court');
      return res.status(400).json({ message: 'Le mot de passe doit contenir au moins 6 caract√®res' });
    }
    
    const userExists = await User.findOne({ $or: [{ email }, { username }] });
    if (userExists) {
      console.log('‚ùå Utilisateur d√©j√† existant');
      return res.status(400).json({ message: 'Email ou nom d\'utilisateur d√©j√† utilis√©' });
    }

    const user = new User({
      email,
      password,
      username
    });

    await user.save();
    console.log('‚úÖ Utilisateur cr√©√© avec succ√®s:', user._id);

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET || 'votre_secret_jwt', {
      expiresIn: '30d'
    });

    res.status(201).json({
      _id: user._id,
      email: user.email,
      username: user.username,
      profilePicture: user.profilePicture || '',
      location: user.location || { type: 'Point', coordinates: [0, 0] },
      bio: user.bio || '',
      token
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation de l\'utilisateur:', error);
    res.status(500).json({ message: 'Erreur lors de la cr√©ation de l\'utilisateur', error: error.message });
  }
};

// Connexion utilisateur
exports.login = async (req, res) => {
  try {
    console.log('üîë Tentative de connexion avec:', req.body);
    const { email, password } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      console.log('‚ùå Utilisateur non trouv√© pour l\'email:', email);
      return res.status(401).json({ message: 'Email ou mot de passe incorrect' });
    }

    console.log('‚úÖ Utilisateur trouv√©:', user.username);
    const isMatch = await user.comparePassword(password);
    console.log('üîê R√©sultat de la comparaison du mot de passe:', isMatch);

    if (!isMatch) {
      console.log('‚ùå Mot de passe incorrect');
      return res.status(401).json({ message: 'Email ou mot de passe incorrect' });
    }

    const token = jwt.sign({ id: user._id }, process.env.JWT_SECRET || 'votre_secret_jwt', {
      expiresIn: '30d'
    });

    console.log('‚úÖ Connexion r√©ussie pour:', user.username);
    res.json({
      _id: user._id,
      email: user.email,
      username: user.username,
      profilePicture: user.profilePicture || '',
      location: user.location || { type: 'Point', coordinates: [0, 0] },
      bio: user.bio || '',
      token
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la connexion:', error);
    res.status(500).json({ message: 'Erreur lors de la connexion', error: error.message });
  }
};

// Mettre √† jour le profil utilisateur
exports.updateProfile = async (req, res) => {
  try {
    const { username, profilePicture, location } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }

    if (username) user.username = username;
    if (profilePicture) user.profilePicture = profilePicture;
    if (location) user.location = location;

    await user.save();
    res.json(user);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la mise √† jour du profil', error: error.message });
  }
};

// Rechercher des utilisateurs par nom d'utilisateur
exports.searchUsers = async (req, res) => {
  try {
    const { query } = req.query;
    const users = await User.find({
      username: { $regex: query, $options: 'i' }
    }).select('-password');
    
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la recherche d\'utilisateurs', error: error.message });
  }
};

// Trouver des utilisateurs √† proximit√©
exports.findNearbyUsers = async (req, res) => {
  try {
    const { longitude, latitude, maxDistance = 5000 } = req.query;
    
    const users = await User.find({
      location: {
        $near: {
          $geometry: {
            type: 'Point',
            coordinates: [parseFloat(longitude), parseFloat(latitude)]
          },
          $maxDistance: parseInt(maxDistance)
        }
      }
    }).select('-password');

    res.json(users);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la recherche d\'utilisateurs √† proximit√©', error: error.message });
  }
};

// Ajouter un ami
exports.addFriend = async (req, res) => {
  try {
    const { friendId } = req.body;
    const userId = req.user.id;

    const user = await User.findById(userId);
    const friend = await User.findById(friendId);

    if (!user || !friend) {
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }

    if (user.friends.includes(friendId)) {
      return res.status(400).json({ message: 'Cet utilisateur est d√©j√† votre ami' });
    }

    user.friends.push(friendId);
    await user.save();

    res.json({ message: 'Ami ajout√© avec succ√®s' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de l\'ajout d\'un ami', error: error.message });
  }
};

// R√©initialiser le mot de passe
exports.resetPassword = async (req, res) => {
  try {
    const { email, newPassword } = req.body;
    
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }

    // Hash du nouveau mot de passe
    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(newPassword, salt);
    
    await user.save();
    
    res.json({ message: 'Mot de passe r√©initialis√© avec succ√®s' });
  } catch (error) {
    console.error('Erreur lors de la r√©initialisation du mot de passe:', error);
    res.status(500).json({ message: 'Erreur lors de la r√©initialisation du mot de passe' });
  }
};

// Supprimer le profil utilisateur
exports.deleteProfile = async (req, res) => {
  try {
    const userId = req.user.id;
    await User.findByIdAndDelete(userId);
    res.json({ message: 'Profil supprim√© avec succ√®s' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la suppression du profil', error: error.message });
  }
};

// Envoyer une demande d'ami
exports.sendFriendRequest = async (req, res) => {
  try {
    const { userId } = req.params;
    const currentUser = await User.findById(req.user.id);
    const targetUser = await User.findById(userId);

    if (!targetUser) {
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }

    // V√©rifier si une demande existe d√©j√†
    const existingRequest = targetUser.friendRequests.find(
      request => request.from.toString() === req.user.id
    );

    if (existingRequest) {
      return res.status(400).json({ message: 'Une demande d\'ami existe d√©j√†' });
    }

    // Ajouter la demande
    targetUser.friendRequests.push({
      from: req.user.id,
      status: 'pending'
    });

    await targetUser.save();
    res.json({ message: 'Demande d\'ami envoy√©e' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de l\'envoi de la demande d\'ami', error: error.message });
  }
};

// G√©rer une demande d'ami (accepter/rejeter)
exports.handleFriendRequest = async (req, res) => {
  try {
    const { requestId } = req.params;
    const { action } = req.body; // 'accept' ou 'reject'
    const currentUser = await User.findById(req.user.id);

    const request = currentUser.friendRequests.id(requestId);
    if (!request) {
      return res.status(404).json({ message: 'Demande non trouv√©e' });
    }

    if (action === 'accept') {
      // Ajouter aux amis des deux c√¥t√©s
      currentUser.friends.push(request.from);
      const otherUser = await User.findById(request.from);
      otherUser.friends.push(currentUser._id);
      await otherUser.save();
    }

    // Mettre √† jour le statut de la demande
    request.status = action === 'accept' ? 'accepted' : 'rejected';
    await currentUser.save();

    res.json({ message: `Demande ${action === 'accept' ? 'accept√©e' : 'rejet√©e'}` });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors du traitement de la demande d\'ami', error: error.message });
  }
};

// Obtenir la liste des amis
exports.getFriends = async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .populate('friends', 'username profilePicture');
    res.json(user.friends);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des amis', error: error.message });
  }
};

// Obtenir les demandes d'amis
exports.getFriendRequests = async (req, res) => {
  try {
    const user = await User.findById(req.user.id)
      .populate('friendRequests.from', 'username profilePicture');
    res.json(user.friendRequests);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des demandes d\'amis', error: error.message });
  }
};

// Supprimer un ami
exports.removeFriend = async (req, res) => {
  try {
    const { userId } = req.params;
    const currentUser = await User.findById(req.user.id);
    const otherUser = await User.findById(userId);

    // Supprimer des deux c√¥t√©s
    currentUser.friends = currentUser.friends.filter(
      friend => friend.toString() !== userId
    );
    otherUser.friends = otherUser.friends.filter(
      friend => friend.toString() !== req.user.id
    );

    await currentUser.save();
    await otherUser.save();

    res.json({ message: 'Ami supprim√© avec succ√®s' });
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la suppression de l\'ami', error: error.message });
  }
};

// Obtenir le profil de l'utilisateur
exports.getProfile = async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      return res.status(404).json({ message: 'Utilisateur non trouv√©' });
    }
    res.json(user);
  } catch (error) {
    res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration du profil', error: error.message });
  }
}; 